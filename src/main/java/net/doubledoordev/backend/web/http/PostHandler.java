/*
 * Unless otherwise specified through the '@author' tag or comments at
 * the top of the file or on a specific portion of the code the following license applies:
 *
 * Copyright (c) 2014, DoubleDoorDevelopment
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 *  Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 *  The header specified or the above copyright notice, this list of conditions
 *   and the following disclaimer below must be displayed at the top of the source code
 *   of any web page received while using any part of the service this software provides.
 *
 *   The header to be displayed:
 *       This page was generated by DoubleDoorDevelopment's D3Backend or a derivative thereof.
 *
 *  Neither the name of the project nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package net.doubledoordev.backend.web.http;

import net.doubledoordev.backend.Main;
import net.doubledoordev.backend.permissions.Group;
import net.doubledoordev.backend.permissions.User;
import net.doubledoordev.backend.server.Server;
import net.doubledoordev.backend.server.ServerData;
import net.doubledoordev.backend.util.Constants;
import net.doubledoordev.backend.util.PasswordHash;
import net.doubledoordev.backend.util.Settings;
import net.doubledoordev.backend.util.exceptions.OutOfPortsException;
import net.doubledoordev.backend.util.exceptions.PostException;
import org.apache.commons.io.FileUtils;
import org.glassfish.grizzly.http.server.Request;
import org.glassfish.grizzly.http.server.Response;
import org.glassfish.grizzly.http.util.Parameters;

import java.io.File;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Set;

import static net.doubledoordev.backend.util.Constants.*;

/**
 * @author Dries007
 */
public class PostHandler
{
    public static final  PostHandler POST_HANDLER    = new PostHandler();
    /*
     * FORM field names
     */
    private static final String      OWNER           = "owner";
    private static final String      NAME            = "name";
    private static final String      USERNAME        = "username";
    private static final String      PASSWORD        = "password";
    private static final String      OLD_PASSWORD    = "oldPassword";
    private static final String      NEW_PASSWORD    = "newPassword";
    private static final String      ARE_YOU_HUMAN   = "areyouhuman";
    private static final String      RAM_MIN         = "RAMmin";
    private static final String      RAM_MAX         = "RAMmax";
    private static final String      PERMGEN         = "PermGen";
    private static final String      EXTRA_JAVA_PARM = "extraJavaParameters";
    private static final String      EXTRA_MC_PARM   = "extraMCParameters";
    private static final String      ADMINS          = "admins";
    private static final String      COOWNERS        = "coOwners";
    private static final String      JARNAME         = "jarname";
    private static final String      RCON_PASS       = "rconpass";
    private static final String      RCON_PORT       = "rconport";
    private static final String      SERVER_PORT     = "serverport";
    private static final String      IP              = "ip";
    private static final String      AUTOSTART       = "autostart";
    private static final String      LOGOUT          = "logout";

    private PostHandler()
    {
    }

    public String handle(HashMap<String, Object> data, String uri, Request request, Response response) throws Exception
    {
        try
        {
            switch (uri)
            {
                case LOGIN_URL:
                    return doLogin(uri, request, response);
                case REGISTER_URL:
                    return doRegister(uri, request, response);
                case NEWSERVER_URL:
                    return doNewserver(data, uri, request, response);
            }
        }
        catch (PostException e)
        {
            data.put(MESSAGE, e.getLocalizedMessage());
        }
        return uri;
    }

    private String doNewserver(HashMap<String, Object> data, String uri, Request request, Response response) throws PostException
    {
        Parameters parameters = request.getParameters();
        Set<String> names = request.getParameterNames();

        User user = (User) data.get(USER);
        if (user == null) throw new PostException("Not logged in.");
        if (user.getMaxServers() != -1 && user.getServerCount() >= user.getMaxServers()) throw new PostException("Max server count reached.");
        ServerData serverData = new ServerData();
        if (user.getGroup() == Group.ADMIN && names.contains(OWNER)) serverData.owner = parameters.getParameter(OWNER);
        else serverData.owner = user.getUsername();

        serverData.ID = serverData.owner + "_" + parameters.getParameter(NAME);
        if (Settings.getServerByName(serverData.ID) != null) throw new PostException("Duplicate server ID");

        serverData.ramMin = Integer.parseInt(parameters.getParameter(RAM_MIN));
        serverData.ramMax = Integer.parseInt(parameters.getParameter(RAM_MAX));
        if (serverData.ramMax < serverData.ramMin)
        {
            int temp = serverData.ramMax;
            serverData.ramMax = serverData.ramMin;
            serverData.ramMin = temp;
        }
        if (user.getMaxRam() != -1 && user.getMaxRamLeft() < serverData.ramMax) throw new PostException("You are over your max RAM.");
        if (serverData.ramMax < 2 || serverData.ramMin < 2) throw new PostException("RAM settings invalid.");

        serverData.permGen = Integer.parseInt(parameters.getParameter(PERMGEN));
        if (serverData.permGen < 2) throw new PostException("PermGen settings invalid.");

        if (parameters.getParameter(EXTRA_JAVA_PARM).trim().length() != 0) serverData.extraJavaParameters = Arrays.asList(parameters.getParameter(EXTRA_JAVA_PARM).trim().split("\n"));
        if (parameters.getParameter(EXTRA_MC_PARM).trim().length() != 0) serverData.extraMCParameters = Arrays.asList(parameters.getParameter(EXTRA_MC_PARM).trim().split("\n"));
        if (parameters.getParameter(ADMINS).trim().length() != 0) serverData.admins = Arrays.asList(parameters.getParameter(ADMINS).trim().split("\n"));
        if (parameters.getParameter(COOWNERS).trim().length() != 0) serverData.coOwners = Arrays.asList(parameters.getParameter(COOWNERS).trim().split("\n"));

        serverData.jarName = parameters.getParameter(JARNAME);
        serverData.rconPswd = parameters.getParameter(RCON_PASS);
        try
        {
            serverData.serverPort = Settings.SETTINGS.fixedPorts ? Settings.SETTINGS.portRange.getNextAvailablePort() : Integer.parseInt(parameters.getParameter(SERVER_PORT));
            serverData.rconPort = Settings.SETTINGS.fixedPorts ? Settings.SETTINGS.portRange.getNextAvailablePort(serverData.serverPort) : Integer.parseInt(parameters.getParameter(RCON_PORT));
        }
        catch (OutOfPortsException e)
        {
            throw new PostException("The backend ran out of ports to assign.");
        }
        serverData.ip = parameters.getParameter(IP);
        serverData.autoStart = names.contains(AUTOSTART) && parameters.getParameter(AUTOSTART).equals("on");

        Server server = new Server(serverData, true);
        Settings.SETTINGS.servers.put(serverData.ID, server);
        Settings.save();
        data.put(SERVER, server);

        try
        {
            FileUtils.writeStringToFile(new File(server.getFolder(), "eula.txt"),
                    "#The server owner indicated to agree with the EULA when submitting the from that produced this server instance.\n" +
                            "#That means that there is no need for extra halting of the server startup sequence with this stupid file.\n" +
                            "#" + new Date().toString() + "\n" +
                            "eula=true\n");
        }
        catch (IOException e)
        {
            server.printLine("Error making the eula file....");
            e.printStackTrace();
        }
        try
        {
            response.sendRedirect(Constants.SERVER_URL + serverData.ID);
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }

        return uri;
    }

    private String doRegister(String uri, Request request, Response response) throws PostException
    {
        Parameters parameters = request.getParameters();
        Set<String> names = request.getParameterNames();

        if (names.contains(USERNAME) && names.contains(PASSWORD) && names.contains(ARE_YOU_HUMAN))
        {
            String username = parameters.getParameter(USERNAME);
            boolean admin = Main.adminKey != null && parameters.getParameter(ARE_YOU_HUMAN).equals(Main.adminKey);
            if (!admin && !parameters.getParameter(ARE_YOU_HUMAN).trim().equals("4")) throw new PostException("You failed the human test...");
            User user = Settings.getUserByName(username);
            if (user != null) throw new PostException("Username taken.");
            if (!USERNAME_PATTERN.matcher(username).matches()) throw new PostException("Username contains invalid chars.<br>Only a-Z, 0-9, _ and - please.");
            try
            {
                user = new User(username, PasswordHash.createHash(parameters.getParameter(PASSWORD)));
                if (admin)
                {
                    user.setGroup(Group.ADMIN);
                    Main.adminKey = null;
                    Main.LOGGER.warn("Admin key claimed. You cannot use it anymore!");
                }
                Settings.SETTINGS.users.put(user.getUsername().toLowerCase(), user);
                request.getSession().setAttribute(USER, user);
                Settings.save();

                return LOGIN_URL;
            }
            catch (NoSuchAlgorithmException | InvalidKeySpecException e)
            {
                // Hash algorithm doesn't work.
                throw new RuntimeException(e);
            }
        }
        else throw new PostException("Form not of known format.");
    }

    private String doLogin(String uri, Request request, Response response) throws PostException
    {
        Parameters parameters = request.getParameters();
        Set<String> names = request.getParameterNames();

        if (names.contains(USERNAME) && names.contains(PASSWORD))
        {
            User user = Settings.getUserByName(parameters.getParameter(USERNAME));
            if (user == null) throw new PostException(String.format("User %s can't be found.", parameters.getParameter(USERNAME)));
            if (!user.verify(parameters.getParameter(PASSWORD))) throw new PostException("Password wrong.");
            request.getSession().setAttribute(USER, user);
        }
        else if (names.contains(LOGOUT))
        {
            request.getSession().attributes().clear();
            request.changeSessionId();
        }
        else if (names.contains(OLD_PASSWORD) && names.contains(NEW_PASSWORD))
        {
            User user = (User) request.getSession().getAttribute(USER);
            if (!user.updatePassword(parameters.getParameter(OLD_PASSWORD), parameters.getParameter(NEW_PASSWORD))) throw new PostException("Password wrong.");
        }
        else throw new PostException("Form not of known format.");

        return uri;
    }
}
